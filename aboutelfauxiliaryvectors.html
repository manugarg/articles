---
title: About ELF Auxiliary Vectors
sharing: true
url: /aboutelfauxiliaryvectors.html
---
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html prefix="og: http://ogp.me/ns#">
<head>
  {% include header.html %}
  {% include css.html %}
  {% include google-analytics.html %} 
</head>

<body id="onecolumn">

  <div id="container">
      <h1 id="page-title">About ELF Auxiliary Vectors</h1>
      <p><i>"Mysterious carriers of information from kernelspace to userspace."</i></p>
      {% include sharing.html %}

      <div id="main-content">        
          <p>
          ELF auxiliary vectors are a mechanism to transfer certain kernel level information to the user processes.
          An example of such an information is the pointer to the <a href="systemcallinlinux2_6.html">system call
          </a> entry point in the memory (AT_SYSINFO); this information is dynamic in nature and is only known
          after kernel has finished up loading.
          </p><p> 
          The information is passed on to the user processes by binary loaders which are part of the kernel
          subsystem itself; either built-in the kernel or a kernel module. Binary loaders convert a binary file,
          a program, into a process on the system. Usually there is a different loader for each binary
          format; thankfully there are not many binary formats - most of the linux based systems now use ELF
          binaries.
          ELF binary loader is defined in the following file <a href="https://github.com/torvalds/linux/blob/master/fs/binfmt_elf.c">
          /usr/src/linux/fs/binfmt_elf.c</a>. 
          </p><p>
          The ELF loader parses the ELF file, maps the various program segments in the memory, sets up the entry
          point and initializes the process stack. It puts ELF auxiliary vectors on the process
          stack along with other information like argc, argv, envp. After initialization, a process' stack looks
          something like this:
          </p>

<pre>
position            content                     size (bytes) + comment
  ------------------------------------------------------------------------
  stack pointer ->  [ argc = number of args ]     4
                    [ argv[0] (pointer) ]         4   (program name)
                    [ argv[1] (pointer) ]         4
                    [ argv[..] (pointer) ]        4 * x
                    [ argv[n - 1] (pointer) ]     4
                    [ argv[n] (pointer) ]         4   (= NULL)

                    [ envp[0] (pointer) ]         4
                    [ envp[1] (pointer) ]         4
                    [ envp[..] (pointer) ]        4
                    [ envp[term] (pointer) ]      4   (= NULL)

                    [ auxv[0] (Elf32_auxv_t) ]    8
                    [ auxv[1] (Elf32_auxv_t) ]    8
                    [ auxv[..] (Elf32_auxv_t) ]   8
                    [ auxv[term] (Elf32_auxv_t) ] 8   (= AT_NULL vector)

                    [ padding ]                   0 - 16

                    [ argument ASCIIZ strings ]   >= 0
                    [ environment ASCIIZ str. ]   >= 0

  (0xbffffffc)      [ end marker ]                4   (= NULL)

  (0xc0000000)      < bottom of stack >           0   (virtual)
  ------------------------------------------------------------------------
</pre>


<p> ELF loader puts an array (auxv) of ELF auxiliary vectors at the bottom of the stack.

The structure of an auxiliary vector is defined in /usr/include/elf.h as:

<pre>
typedef struct
{
  uint32_t a_type;              /* Entry type */
  union
    {
      uint32_t a_val;           /* Integer value */
      /* We use to have pointer elements added here.  We cannot do that,
         though, since it does not work when using 32-bit definitions
         on 64-bit platforms and vice versa.  */
    } a_un;
} Elf32_auxv_t;
</pre>

<i>a_type</i> defines the entry type and union <i>a_un</i> defines the entry value. Legal values for <i>a_type</i>
are defined in <i>elf.h</i>. To give you an idea, here are some of the vectors:<br></p>

<pre>
/* Legal values for a_type (entry type).  */
#define AT_NULL         0               /* End of vector */
#define AT_IGNORE       1               /* Entry should be ignored */
#define AT_EXECFD       2               /* File descriptor of program */
#define AT_PHDR         3               /* Program headers for program */
#define AT_PHENT        4               /* Size of program header entry */
#define AT_PHNUM        5               /* Number of program headers */
#define AT_PAGESZ       6               /* System page size */
#define AT_BASE         7               /* Base address of interpreter */
#define AT_FLAGS        8               /* Flags */
#define AT_ENTRY        9               /* Entry point of program */
#define AT_NOTELF       10              /* Program is not ELF */
#define AT_UID          11              /* Real uid */
#define AT_EUID         12              /* Effective uid */
#define AT_GID          13              /* Real gid */
#define AT_EGID         14              /* Effective gid */
#define AT_CLKTCK       17              /* Frequency of times() */
/* Pointer to the global system page used for system calls and other nice things.  */
#define AT_SYSINFO      32
#define AT_SYSINFO_EHDR 33
</pre>

<p>The whole list is defined in the header files: <a href="https://github.com/torvalds/linux/blob/v3.19/include/uapi/linux/auxvec.h">
/usr/include/linux/auxvec.h</a> and <a href="https://github.com/torvalds/linux/blob/v3.19/arch/ia64/include/uapi/asm/auxvec.h">asm/auxvec.h</a>.
(Since all entry types (a_type) start with AT_, ELF auxiliary vectors are also called
AT_ elf parameters.)</p>

Example of adding AT_SYSINFO auxiliary vector:
<pre>
<a href="https://github.com/torvalds/linux/blob/v3.19/arch/ia64/include/asm/elf.h#L215">arch/ia64/include/asm/elf.h:
</a>
#define ARCH_DLINFO								\
do {										\
	extern char __kernel_syscall_via_epc[];					\
	NEW_AUX_ENT(AT_SYSINFO, (unsigned long) __kernel_syscall_via_epc);	\
	NEW_AUX_ENT(AT_SYSINFO_EHDR, (unsigned long) GATE_EHDR);		\
} while (0)

<a href="https://github.com/torvalds/linux/blob/v3.19/fs/binfmt_elf.c#L218">fs/binfmt_elf.c:</a>

#define NEW_AUX_ENT(id, val) \
	do { \
		elf_info[ei_index++] = id; \
		elf_info[ei_index++] = val; \
	} while (0)
</pre>
<br>

<h4>Spying On ELF Auxiliary Vectors:</h4><p>ELF auxiliary vectors are mostly used by the program interpreter and hence are not discussed much by the programmers. The ELF auxiliary vectors being passed to a program can be seen by setting environment variable LD_SHOW_AUXV to 1.<br></p>

<pre>
[root@localhost ~]# LD_SHOW_AUXV=1 /bin/true
AT_SYSINFO:      0x9ff400
AT_SYSINFO_EHDR: 0x9ff000
AT_HWCAP:    fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat clflush dts acpi mmx fxsr sse sse2 ss
AT_PAGESZ:       4096
AT_CLKTCK:       100
..........
</pre>

<p>Programmers can also access these parameters inside their programs by reaching out to the auxv array on the stack. Following program snippet shows a way to find out the value of AT_SYSINFO parameter:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;elf.h&gt;

main(int argc, char* argv[], char* envp[])
{
        Elf32_auxv_t *auxv;
        while(*envp++ != NULL); /*from stack diagram above: *envp = NULL marks end of envp*/

        for (auxv = (Elf32_auxv_t *)envp; auxv-&gt;a_type != AT_NULL; auxv++)
      /* auxv-&gt;a_type = AT_NULL marks the end of auxv */
        {
                if( auxv-&gt;a_type == AT_SYSINFO)
                        printf("AT_SYSINFO is: 0x%x\n", auxv-&gt;a_un.a_val);
        }
}

[root@localhost ~]# gcc -o ats ats.c
[root@localhost ~]# ./ats
AT_SYSINFO: 0xc24400
</pre>


<br>We can verify that our program is working properly by using LD_SHOW_AUXV environment variable:

<pre>
[root@localhost ~]# LD_SHOW_AUXV=1 ./ats | grep AT_SYSINFO
AT_SYSINFO:      0xdd9400
AT_SYSINFO_EHDR: 0xdd9000
AT_SYSINFO is: 0xdd9400
</pre>

<hr/>
<p>Well, that&#39;s all I had to say about Elf auxiliary vectors. I had to go in search of them because
of my previous article on <a href="systemcallinlinux2_6.html">&quot;Sysenter Based System Call Mechanism
in Linux 2.6&quot;</a>.Â </p>
<p>Credit: Stack diagram has been taken from the phrack article http://www.phrack.org/phrack/58/p58-0x05 by grugq and scut.</p>
      </div>
      <!-- /main-content -->
    {% include footer.html %}
  </div>
  <!-- /container -->

</body>
</html>

